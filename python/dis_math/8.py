import matplotlib.pyplot as plt
import networkx as nx
from collections import defaultdict
import random

class FordFulkerson:
    def __init__(self, graph):
        # Инициализация графа и множества посещённых вершин
        self.graph = graph  # Граф представлен в виде словаря
        self.visited = set()  # Множество для отслеживания посещённых вершин

    def ford_fulkerson(self, source, sink):
        max_flow = 0

        while True:
            # Поиск пути от source к sink с помощью DFS
            path = self._dfs(source, sink, [])
            if not path:
                break

            # Определение минимальной ёмкости по найденному пути
            min_capacity = float("inf")
            for u, v in path:
                min_capacity = min(min_capacity, self.graph[u][v])  # Находим минимальную ёмкость

            # Обновление пропускных способностей по найденному пути
            for u, v in path:
                self.graph[u][v] -= min_capacity  # Уменьшаем ёмкость прямого ребра
                self.graph[v][u] += min_capacity  # Увеличиваем ёмкость обратного ребра

            max_flow += min_capacity  # Увеличиваем общий максимальный поток

        return max_flow

    def _dfs(self, node, sink, path):
        # Метод для поиска пути с помощью DFS
        if node == sink:
            return path  # Если достигли sink, возвращаем текущий путь
        self.visited.add(node)  # Добавляем текущую вершину в множество посещённых
        for next_node, capacity in self.graph[node].items():
            # Перебираем соседние вершины
            if next_node not in self.visited and capacity > 0:  # Если вершина не посещена и ёмкость положительна
                new_path = path + [(node, next_node)]  # Добавляем текущее ребро в путь
                result = self._dfs(next_node, sink, new_path)  # Рекурсивный вызов для следующей вершины
                if result:
                    return result
        return None

    def min_cut(self, source):
        # Метод для нахождения минимального разреза
        self.visited.add(source)  # Добавляем начальную вершину в множество посещённых
        reachable_nodes = set()  # Множество для хранения достижимых вершин

        stack = [source]  # Стек для обхода графа
        while stack:
            node = stack.pop()  # Извлекаем вершину из стека
            reachable_nodes.add(node)  # Добавляем её в множество достижимых
            for next_node, capacity in self.graph[node].items():
                # Перебираем соседние вершины
                if next_node not in self.visited and capacity > 0:
                    stack.append(next_node)  # Добавляем в стек для дальнейшего обхода
                    self.visited.add(next_node)  # Помечаем как посещённую

        min_cut = []
        for u in reachable_nodes:
            for v, capacity in self.graph[u].items():
                if v not in reachable_nodes:
                    min_cut.append((u, v))  # Если v недостижима, добавляем ребро в минимальный разрез

        return min_cut  # Возвращаем найденный минимальный разрез

def visualize_graph(edges):
    G = nx.DiGraph()
    for u, v, capacity in edges:
        G.add_edge(u, v, capacity=capacity)
    pos = nx.spring_layout(G)
    nx.draw(G, pos, with_labels=True, node_color="skyblue", node_size=500, font_size=12, font_weight="bold")
    nx.draw_networkx_edge_labels(G, pos, edge_labels={(u, v): str(d["capacity"]) for u, v, d in G.edges(data=True)})
    plt.title("Граф сети")
    plt.show()

def find_max_flow_min_cut(edges):
    G = nx.DiGraph()

    for edge in edges:
        G.add_edge(edge[0], edge[1], capacity=edge[2])

    source = 'S'  # Заменяем на буквы
    sink = 'T'    # Заменяем на буквы
    flow_value, flow_dict = nx.maximum_flow(G, source, sink)
    min_cut = nx.minimum_cut(G, source, sink)

    return flow_value, min_cut

# Список рёбер сети с заменой на буквы
edges = [['S', 'a', 3], ['S', 'b', 7], ['S', 'c', 5],
         ['a', 'e', 4], ['a', 'b', 6],
         ['c', 'b', 3], ['c', 'd', 4],
         ['b', 'f', 9],
         ['d', 'g', 7], ['d', 'b', 2],
         ['e', 'b', 8], ['e', 'f', 3], ['e', 'i', 3],
         ['f', 'i', 4],
         ['g', 'b', 6],['g', 'f', 5],['g', 'h', 5],['g', 'T', 7],
         ['h', 'T', 11],
         ['i', 'T', 11]]

# Находим максимальный поток и минимальный разрез
max_flow, min_cut = find_max_flow_min_cut(edges)

print("Максимальный поток:", max_flow)
print("Минимальный разрез:", min_cut)

# Визуализируем граф
visualize_graph(edges)

# построим граф с другими весами
edges2 = []
for i in range(len(edges)):
    cur_edge = edges[i];
    cur_edge[2] = random.randint(100, 1000)
    edges2.append(cur_edge)

max_flow2, min_cut2 = find_max_flow_min_cut(edges2)

print("Максимальный поток:", max_flow2)
print("Минимальный разрез:", min_cut2)
graph2 = defaultdict(dict)
for u, v, capacity in edges2:
    graph2[u][v] = capacity
    graph2[v][u] = 0  # Обратные ребра для обратного потока

visualize_graph(edges2)








"""
        Алгоритм действий программы
1. Импорт необходимых библиотек
   - Импортируются библиотеки `matplotlib.pyplot` для визуализации, `networkx` для работы с графами, `collections.defaultdict` 
   для удобного создания графа и `random` для генерации случайных весов.

2. Определение класса `FordFulkerson`
   - Создаётся класс `FordFulkerson`, который принимает граф в виде словаря и инициализирует множество `visited` для отслеживания 
   посещённых вершин.

3. Метод `ford_fulkerson`
   - Принимает начальную (`source`) и конечную (`sink`) вершины.
   - Инициализирует переменную `max_flow` для хранения максимального потока.
   - Запускает бесконечный цикл для поиска путей от `source` к `sink` с помощью метода `_dfs`.

4. Поиск пути с помощью метода `_dfs`
   - Проверяет, достигнута ли конечная вершина. Если да, возвращает текущий путь.
   - Если нет, добавляет текущую вершину в множество `visited` и перебирает соседние вершины.
   - Если соседняя вершина доступна (не посещена и имеет положительную ёмкость), рекурсивно вызывает `_dfs`.
   - Если путь найден, возвращает его, иначе возвращает `None`.

5. Обновление пропускных способностей
   - После нахождения пути определяет минимальную ёмкость в найденном пути.
   - Обновляет пропускные способности рёбер в графе, уменьшая их для прямого ребра и увеличивая для обратного.

6. Возврат максимального потока
   - После завершения цикла возвращает значение `max_flow`, которое является максимальным потоком в сети.

7. Метод `min_cut`
   - Принимает начальную вершину (`source`) и определяет достижимые вершины, используя обход в глубину.
   - Составляет список рёбер, которые соединяют достижимые вершины с недостижимыми, и возвращает его как минимальный разрез.

8. Функция `visualize_graph`
   - Принимает список рёбер и создаёт направленный граф с помощью `networkx`.
   - Визуализирует граф с узлами и рёбрами, отображая пропускные способности рёбер.

9. Функция `find_max_flow_min_cut`
   - Создаёт направленный граф из списка рёбер.
   - Определяет начальную (`source`) и конечную (`sink`) вершины.
   - Использует встроенные функции `maximum_flow` и `minimum_cut` из `networkx` для нахождения максимального потока и минимального разреза.

10. Определение рёбер сети
    - Определяется список рёбер сети в виде списка списков, где каждый подсписок содержит начальную вершину, конечную вершину и пропускную способность.

11. Поиск максимального потока и минимального разреза
    - Вызывается функция `find_max_flow_min_cut`, и выводятся результаты для первого набора рёбер.

12. Визуализация графа
    - Вызывается функция `visualize_graph` для отображения графа с заданными рёбрами.

13. Создание нового графа с случайными весами
    - Генерируется новый список рёбер с случайными пропускными способностями.
    - Вызывается функция `find_max_flow_min_cut` для нового графа и выводятся результаты.

14. Визуализация нового графа
    - Вызывается функция `visualize_graph` для отображения графа с новыми случайными весами.
"""

'''
Максимальный поток - это мера количества данных или ресурсов, которые могут пройти через сеть от источника к стоку. 
В контексте сетевых графов и задачи максимального потока обычно рассматривается сеть, в которой вершины представляют собой
 узлы (например, компьютеры, маршрутизаторы), а ребра представляют собой каналы связи между этими узлами.

Источник (source) - это начальная вершина сети, из которой начинается поток данных. Сток (sink) - это конечная вершина, 
в которой поток данных завершается.

Максимальный поток в сети - это максимальное количество данных, которое может протекать от источника к стоку, при условии, 
что соблюдаются определенные ограничения на пропускную способность (capacity) каждого канала связи (ребра).

Алгоритмы максимального потока используются для решения множества задач, включая планирование трафика в сетях передачи данных, 
оптимизацию транспортных потоков в транспортных сетях, а также для моделирования потоков жидкости или газа в физических системах.

Цель алгоритма максимального потока состоит в том, чтобы найти такой путь от источника к стоку, по которому суммарный поток 
данных будет максимальным. При этом учитываются пропускные способности всех каналов связи на этом пути.

Вершины и ребра могут иметь различные пропускные способности, и максимальный поток определяется таким образом, чтобы суммарный 
поток через каждое ребро не превышал его пропускную способность, и чтобы суммарный поток через каждую вершину (кроме источника
 и стока) был равен нулю.

Поиск максимального потока полезен, например, при планировании маршрутов в сети так, чтобы максимизировать пропускную способность
 и избежать перегрузок.
'''
'''
Минимальный разрез в сети представляет собой разделение сети на две части путем удаления ребер таким образом,
 чтобы максимальный поток от источника к стоку был минимален.
Более формально, минимальный разрез - это множество ребер сети, удаление которых разделит сеть на две непересекающиеся
 подсети: одна содержит источник, а другая содержит сток. При этом суммарная пропускная способность удаленных ребер будет 
 минимальной среди всех возможных разрезов. То есть, минимальный разрез определяет наименьшее количество ресурсов (или данных), 
 которые необходимо удалить из сети, чтобы полностью разделить источник и сток, не давая возможности потоку данных достичь стока из источника.
В контексте задачи максимального потока, минимальный разрез обычно используется для определения узких мест в сети, которые могут 
ограничивать максимальный поток. После того, как найден максимальный поток, минимальный разрез позволяет определить, какие каналы связи являются 
узкими местами, или наиболее уязвимыми местами в сети.
Например, если удаление определенного ребра приводит к уменьшению максимального потока, это означает, что это ребро является частью минимального 
разреза и является узким местом в сети.
Таким образом, минимальный разрез и максимальный поток тесно связаны и используются вместе для анализа и оптимизации сетевых структур.
'''
